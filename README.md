# Zator  
**Специализированный язык программирования для генерации и обработки AI-контента**

---

## 1. Введение

Zator — это специализированный язык программирования, предназначенный для создания и обработки AI-генерируемого контента (текста и изображений) с использованием API **KoboldCpp**. Язык предоставляет простой и интуитивно понятный синтаксис для построения генеративных пайплайнов с минимальным количеством кода, а также включает встроенные функции для постобработки изображений.

---

## 2. Системные требования и настройка

### Требования
- **ОС**: Windows 10/11
- **Зависимости**:
  - Запущенный экземпляр **KoboldCpp** с включенными API:
    - `/api/v1/generate` — для генерации текста
    - `/sdapi/v1/txt2img` — для генерации изображений (требуется поддержка Stable Diffusion)
  - Библиотеки: `libpng` для обработки изображений
- **Аппаратное обеспечение**: Доступ к GPU рекомендуется для генерации изображений

### Запуск
```bash
zator.exe ваш_скрипт.zator
```

### Настройка сервера
По умолчанию используется локальный сервер:
```python
server = "http://localhost:5001"
```

---

## 3. Синтаксис языка

### 3.1. Комментарии и контекст
```python
# Это однострочный комментарий

context = "Вы — помощник, специализирующийся на создании творческого контента."
```

Контекст используется во всех вызовах генерации как префикс к промпту.

### 3.2. Переменные и типы данных
Zator поддерживает три типа переменных:

#### Текст (`VAR_STRING`)
```python
var greeting = "Привет, мир!"
var story = generate_text("Напишите короткую историю о кобольде", context, 200)
```

#### Целое число (`VAR_INT`)
```python
var counter = 42
var score = 85
```

#### Изображение (`VAR_IMAGE`)
```python
var portrait = generate_img("Портрет дружелюбного кобольда, цифровое искусство", context, 512, 512)
```

### 3.3. F-строки
F-строки позволяют встраивать значения переменных внутрь строк. Синтаксис: `{имя_переменной}`.

```python
var username = "Алексей"
print("Привет, {username}! Сегодняшняя дата: {current_date}")
```

F-строки работают:
- В присваиваниях (`var x = "Привет, {name}"`)
- В аргументах функций (`print`, `save_txt`, `save_img`, `generate_text`, `generate_img`)
- В путях к файлам
- В контексте и промптах

Для вывода литеральных фигурных скобок используйте экранирование: `\{` и `\}`.

### 3.4. Управляющие конструкции

#### Условные операторы
```python
if score > 80 {
    print("Отличный результат!")
} else if score > 60 {
    print("Хороший результат!")
} else {
    print("Нужно улучшить результат.")
}
```

Поддерживаемые операторы сравнения:
- `==`, `!=` — для строк и чисел
- `>`, `<`, `>=`, `<=` — только для целых чисел

#### Циклы
```python
var countdown = 5
repeat 10 {
    countdown = countdown - 1
    print("Осталось времени: {countdown}")
    if countdown <= 0 {
        print("Цикл прерван досрочно")
        break
    }
}
```

Ключевое слово `break` немедленно прерывает выполнение цикла.

---

## 4. Функции генерации контента

### 4.1. Генерация текста
```python
var result = generate_text(prompt, context, max_tokens)
```

**Параметры:**
- `prompt` — строка или имя переменной с промптом
- `context` — контекст, объединяется с промптом
- `max_tokens` — максимальное количество генерируемых токенов

**Используемые параметры API (KoboldCpp):**
```json
{
  "max_length": max_tokens,
  "max_context_length": 2048,
  "temperature": 0.7,
  "top_p": 0.9,
  "top_k": 100,
  "rep_pen": 1.1,
  "use_default_badwordsids": false
}
```

### 4.2. Генерация изображений
```python
var image = generate_img(prompt, context, width, height)
```

**Параметры:**
- `prompt` — описание изображения
- `context` — контекст (может использоваться в f-строках)
- `width`, `height` — размеры в пикселях (рекомендуется кратно 64)

**Используемые параметры API (Stable Diffusion через KoboldCpp):**
```json
{
  "prompt": "...",
  "negative_prompt": "ugly, deformed, noisy, blurry, distorted",
  "width": 512,
  "height": 512,
  "sampler_name": "Euler a",
  "steps": 20,
  "cfg_scale": 7.0,
  "seed": -1
}
```

---

## 5. Функции обработки изображений

### 5.1. Обрезка по цвету (Chroma Key)
```python
var cropped = chroma_key_crop(source_image, x, y[, tolerance])
```

**Параметры:**
- `source_image` — исходное изображение
- `x`, `y` — координаты пикселя с цветом для обрезки
- `tolerance` (опционально) — допуск в процентах (0.0-100.0), по умолчанию 0.0

**Описание:**
Функция обрезает изображение по указанному цвету, делая пиксели этого цвета прозрачными и обрезая пустые границы. Цвет определяется по пикселю с координатами (x, y).

**Пример:**
```python
var photo = generate_img("Фотография на зеленом фоне", context, 512, 512)
var subject = chroma_key_crop(photo, 10, 10, 5.0)  # Обрезка по зеленому цвету с допуском 5%
save_img(subject, "output/subject.png")
```

### 5.2. Масштабирование изображения
```python
var scaled = scale_to(source_image, width, height)
```

**Параметры:**
- `source_image` — исходное изображение
- `width`, `height` — целевые размеры в пикселях

**Описание:**
Функция масштабирует изображение до указанных размеров с использованием ближайшего соседа (nearest neighbor) для сохранения четкости.

**Пример:**
```python
var icon = scale_to(subject, 128, 128)  # Масштабирование до иконки 128x128
save_img(icon, "output/icon.png")
```

---

## 6. Работа с файлами

### 6.1. Сохранение текста
```python
save_txt(variable, "относительный/путь/к/файлу.txt")
```

### 6.2. Сохранение изображений
```python
save_img(variable, "images/fantasy_landscape.png")
```

**Особенности:**
- Файлы сохраняются относительно директории, в которой находится запускаемый `.zator`-скрипт
- Изображения сохраняются в формате PNG
- Если переменная содержит обработанное изображение (после chroma_key_crop или scale_to), используется внутреннее представление

### 6.3. Ввод данных
```python
input(username)
print("Здравствуйте, {username}!")
```

Функция `input()` читает одну строку из stdin (без приглашения).

---

## 7. Вспомогательные функции

### 7.1. Работа с массивами (демонстрационные)
```python
array_push_demo("первый элемент")
array_push_demo("второй элемент")
print_array()
```

Эти функции используются только в демонстрационных целях.

### 7.2. Вставка C-кода
```python
emit_c("embedded/example.c")
```

Сохраняет встроенный пример C-кода в указанный путь.

---

## 8. Примеры использования

### Пример 1: Генерация персонажа и его обработка
```python
context = "Вы — дизайнер игровых персонажей."

# Генерация персонажа на зеленом фоне
var character_prompt = "Игровой персонаж кобольд-маг в фэнтези сеттинге, чистый зеленый фон"
var character_img = generate_img(character_prompt, context, 512, 512)

# Обрезка по зеленому фону
var character_cropped = chroma_key_crop(character_img, 10, 10, 3.0)

# Создание разных размеров для использования в игре
var character_icon = scale_to(character_cropped, 64, 64)
var character_preview = scale_to(character_cropped, 256, 256)

# Сохранение результатов
save_img(character_cropped, "characters/cobold_mag.png")
save_img(character_icon, "characters/icons/cobold_mag.png")
save_img(character_preview, "characters/previews/cobold_mag.png")

print("Персонаж успешно создан и обработан!")
```

### Пример 2: Интерактивный генератор контента с последующей обработкой
```python
context = "Вы — помощник по созданию контента."

print("Введите своё имя:")
input(username)
print("Привет, {username}! Выберите тип контента:")
print("1 — Текстовая история")
print("2 — Изображение персонажа")
input(choice)

if choice == "1" {
    print("Введите тему истории:")
    input(theme)
    var prompt = "Напишите короткую историю на тему '{theme}' в стиле фэнтези."
    var tokens = 250
    var content = generate_text(prompt, context, tokens)
    print("\nВаша история:\n{content}")
    
    print("\nСохранить в файл? (да/нет)")
    input(save_choice)
    if save_choice == "да" {
        save_txt(content, "stories/{username}_{theme}.txt")
    }
}

if choice == "2" {
    print("Введите описание персонажа:")
    input(description)
    var prompt = "Портрет персонажа: {description}, цифровое искусство, профессиональное освещение"
    var character_img = generate_img(prompt, context, 512, 512)
    
    print("Обрезать фон? (да/нет)")
    input(crop_choice)
    if crop_choice == "да" {
        print("Введите координаты для цвета фона (x y):")
        input(coords)
        var x = 10  # Значения по умолчанию
        var y = 10
        # В реальной реализации нужно разобрать coords на x и y
        var cropped_img = chroma_key_crop(character_img, x, y, 5.0)
        
        print("Масштабировать изображение? (да/нет)")
        input(scale_choice)
        if scale_choice == "да" {
            print("Введите целевые размеры (ширина высота):")
            input(sizes)
            var width = 256
            var height = 256
            # В реальной реализации нужно разобрать sizes на width и height
            var final_img = scale_to(cropped_img, width, height)
            save_img(final_img, "characters/{username}_character.png")
        } else {
            save_img(cropped_img, "characters/{username}_character.png")
        }
    } else {
        save_img(character_img, "characters/{username}_character.png")
    }
    print("Изображение сохранено в папку characters/")
}
```

---

## 9. Ограничения и рекомендации

### Текущие ограничения:
- **Условные блоки** поддерживают только **одну команду** после условия
- **Циклы** не поддерживают вложенные `repeat`
- Все пути — **относительные**, базовая директория определяется как папка скрипта
- Для генерации изображений **обязательно** наличие работающего SD API в KoboldCpp

### Рекомендации:
- **Размеры изображений** должны быть **кратны 64 пикселям** для лучшей совместимости с VRAM
- Используйте **умеренные значения** `max_tokens` (до 500) для стабильной работы
- Для **chroma_key_crop** выбирайте пиксели в углах изображения для определения цвета фона
- **Последовательная обработка**: сначала обрежьте фон, затем масштабируйте

---

## 10. Поддержка и развитие

Если вы обнаружили ошибку или хотите предложить улучшение:
1. Убедитесь, что KoboldCpp запущен с нужными API
2. Проверьте логи и ответы от `curl`
3. Создайте issue в репозитории проекта с подробным описанием проблемы

### Планы развития:
- Поддержка вложенных условных блоков
- Добавление функций для наложения изображений
- Интеграция с другими AI API (DALL-E, Midjourney)
- Оптимизация памяти для работы с большими изображениями

---

**Версия документации**: 2.0  
**Дата обновления**: 26 января 2026 г.
